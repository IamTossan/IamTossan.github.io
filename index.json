[{"content":"Here\u0026rsquo;s the link to advent of code day 1.\nPart 1 # We begin with this example:\n3 4 4 3 2 5 1 3 3 9 3 3 Here we need to compute the sum of distances.\nA distance is defined as how far apart two numbers in a pair are.\nThe twist is that the numbers are shuffled and the first pair is the smallest number in the first column and the smallest in the second. The second pair is the second smallest in each column and so on.\nIn this example, the result would be (3 - 1) + (3 - 2) + 0 + 1 + 2 + 5 = 11.\nThis is perfect for a TDD approach. So we start by setting up the test:\n#[cfg(test)] mod tests { use super::*; #[test] fn test_distance() { let test_data = [vec![3, 4, 2, 1, 3, 3], vec![4, 3, 5, 3, 9, 3]]; assert_eq!(compute_distance(\u0026amp;test_data), 11); } } We make 3 decisions right away (that we can still change later):\nthe data structure the function name the function signature We decide to keep an immutable reference for the parameter to avoid the complexity that mutability brings. We\u0026rsquo;ll refactor to \u0026amp;mut if we need a boost in performance.\nrust-analyser is already helping us:\nassert_eq!(compute_distance(\u0026amp;test_data), 11); ^^^^^^^^^^^^^^^^ not found in this scope So we start like this:\nfn compute_distance([xs, ys]: \u0026amp;[Vec\u0026lt;u32\u0026gt;; 2]) -\u0026gt; u32 { 0 } Then cargo test outputs:\ntest tests::test_distance ... FAILED [...] assertion `left == right` failed left: 0 right: 11 Finally we can start implementing the logic:\nimport std::{iter::zip}; fn compute_distance([xs, ys]: \u0026amp;[Vec\u0026lt;u32\u0026gt;; 2]) -\u0026gt; u32 { let mut xs = xs.clone(); let mut ys = ys.clone(); xs.sort(); ys.sort(); zip(xs, ys).map(|(x, y)| x.abs_diff(y)).sum() } test tests::test_distance ... ok Now that the logic is ready, we can pretty much finish the first part.\nfn get_data() -\u0026gt; Result\u0026lt;[Vec\u0026lt;u32\u0026gt;; 2], Box\u0026lt;dyn Error\u0026gt;\u0026gt; { let s = fs::read_to_string(\u0026#34;src/assets/aoc1.txt\u0026#34;)?; let mut out: [Vec\u0026lt;u32\u0026gt;; 2] = [vec![], vec![]]; for l in s.lines() { let xs: Vec\u0026lt;\u0026amp;str\u0026gt; = l.split_whitespace().collect(); out[0].push(xs[0].parse().expect(\u0026#34;should be a number\u0026#34;)); out[1].push(xs[1].parse().expect(\u0026#34;should be a number\u0026#34;)); } Ok(out) } fn main() -\u0026gt; Result\u0026lt;(), Box\u0026lt;dyn Error\u0026gt;\u0026gt; { let s = get_data()?; println!(\u0026#34;distance: {}\u0026#34;, compute_distance(\u0026amp;s)); Ok(()) } Part 2 # Here we have a different logic to compute\nColumn x Column y count of x in y x * count of x in y 3 4 3 9 4 3 1 4 2 5 0 0 1 3 0 0 3 9 3 9 3 3 3 9 \u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; sum 31 We add a test\n#[test] fn test_similarity() { let test_data = [vec![3, 4, 2, 1, 3, 3], vec![4, 3, 5, 3, 9, 3]]; assert_eq!(compute_similarity(\u0026amp;test_data), 31); } And the matching function\nfn compute_similarity([xs, ys]: \u0026amp;[Vec\u0026lt;u32\u0026gt;; 2]) -\u0026gt; u32 { let mut ys_counter = HashMap::\u0026lt;u32, u32\u0026gt;::new(); for e in ys { *ys_counter.entry(*e).or_default() += 1; } xs.iter().map(|x| x * ys_counter.get(x).unwrap_or(\u0026amp;0)).sum() } Update the main function\nfn main() -\u0026gt; Result\u0026lt;(), Box\u0026lt;dyn Error\u0026gt;\u0026gt; { let s = get_data()?; println!(\u0026#34;distance: {}\u0026#34;, compute_distance(\u0026amp;s)); println!(\u0026#34;similarity: {}\u0026#34;, compute_similarity(\u0026amp;s)); Ok(()) } And we\u0026rsquo;re done!\nConclusion # This was a pretty straight-forward challenge. Here\u0026rsquo;s some thoughts:\nthe shorter the feedback loop, the better, being able to do TDD helped tremendously choose the data structure according to the read/write pattern you need be careful about when to mutate: in this challenge we could sort the lists in place in the first part without impacting the second we decided to keep the code easy to reason about at the cost of memory in a more \u0026ldquo;real-world\u0026rdquo; context, that might be considered differently ","date":"4 January 2025","externalUrl":null,"permalink":"/posts/advent-2024-01/","section":"Posts","summary":"","title":"[Write-Up]: Advent 2024 Day 01","type":"posts"},{"content":"","date":"4 January 2025","externalUrl":null,"permalink":"/","section":"IamTossan.github.io","summary":"","title":"IamTossan.github.io","type":"page"},{"content":"","date":"4 January 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"4 January 2025","externalUrl":null,"permalink":"/tags/rust/","section":"Tags","summary":"","title":"Rust","type":"tags"},{"content":"","date":"4 January 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" I just finished reading that book, just before the end of the year. I wish I read these 600 pages earlier in my career.\nThe book consists of 5 parts. It starts with the basic elements of programming: arithmetic, variables, functions\u0026hellip; Then from these basic elements, we build towards more real-life problems to solve, using data structure, order of growth, function compositions and so on\u0026hellip; We define models that correspond to the problems we solve, or should I say, a language to express how we interact with the environment, so naturally we end with the 2 last parts having a taste of writing an interpreter and a compiler.\nHere\u0026rsquo;s some ideas from the book that I liked.\n1. Functional vs Object oriented vs Streams # In the book, we spend the first two parts using only functional programming. It is only in the third (after about 200 pages) that we are introduced to assignment which lead to encapsulation of local state. There is discussion about these two way and their respective challenges. Here\u0026rsquo;s an example:\nclass Account() { constructor(private balance: number) {} withdraw(amount: number): number { this.balance -= number; return this.balance; } } const acc = new Account(100); acc.withdraw(20); // 80 acc.withdraw(20); // 60 In object-oriented, we model things as entities that we can interact with and that can interact with each other. We model the changes of state with assignment. Successive calls to the same procedure can have different results, which can make a complex system difficult to reason with and to test, especially when multiple local states are correlated.\nconst withdrawSteam = (balance: number, amountStream: number[]): number =\u0026gt; { return amountStream.reduce((acc, cur) =\u0026gt; acc - cur, balance); }; console.log(withdrawSteam(100, [20, 20])); // 60 console.log(withdrawSteam(100, [20, 20])); // 60 In functional, we model things like an electrical circuit where each element outputs a computation based on its inputs. Successive calls will output the same results each time. In essence, we model time explicitly, however, time-related problems like when two changes to the same account occur (using mutexes), or and priority rules when merging streams need to be addressed.\n2. Dispatching on type and additivity # This is a powerful technique to obtain modularity in the implementation while keeping a clean API.\nconst getRealPart = (value) =\u0026gt; { if(type === \u0026#34;rectangular\u0026#34;) { ... } else if (type === \u0026#34;polar\u0026#34;) { ... } }; const getImagPart = (value) =\u0026gt; {...}; const getMagnitude = (value) =\u0026gt; {...}; const getAngle = (value) =\u0026gt; {...}; Here, if you need to add another type, you would need to go into every function.\nimport { rectangularOperations } from \u0026#34;somewhere-else\u0026#34;; const polarOperations = { getRealPart(value) {...}, getImagPart(value) {...}, getMagnitude(value) {...}, getAngle(value) {...}, }; const operationTable = { polar: polarOperations, rectangular: rectangularOperations, }; const applyOnComplexNumber = ( operation: string, complexNumber: { type: string; value: ComplexNumberValue }, ): [any, null] | [null, Error] =\u0026gt; { if (!operationTable[complexNumber.type]) { return [null, new Error(\u0026#34;type not implemented\u0026#34;)]; } if (!operationTable[complexNumber.type].operation) { return [ null, new Error( `operation {operation} not implemented on type {complexNumber.type}`, ), ]; } return [operationTable[complexNumber.type](complexNumber.value), null]; }; This way, we can easily package these operations by type and add another like a plugin.\n3. Constraints # This pattern can be used when the computation is not unidirectional and you need to propagate constraints, when a value depends on one or more others. This is a common thing in frontend frameworks nowadays, but I was pleasantly surprised to find this in a book originally written in 1985.\nclass Temperature { private _val: { c: null | number; f: null | number } = { c: null, f: null, }; private _cb: Array\u0026lt;(c: null | number, f: null | number) =\u0026gt; unknown\u0026gt; = []; set c(value: null | number) { if (value === null) { this._val = { c: null, f: null, }; } else { this._val = { c: value, f: (9 / 5) * value + 32, }; } this.onChange(); } set f(value: null | number) { if (value === null) { this._val = { c: null, f: null, }; } else { this._val = { f: value, c: (value - 32) * (5 / 9), }; } this.onChange(); } addCallback(f: (c: null | number, f: null | number) =\u0026gt; unknown) { this._cb.push(f); } onChange() { this._cb.forEach((cb) =\u0026gt; cb(this._val.c, this._val.f)); } } const temp = new Temperature(); temp.addCallback((c, f) =\u0026gt; { console.log(`Celcius temp: ${c ?? \u0026#34;???\u0026#34;}`); console.log(`Fahrenheit temp: ${f ?? \u0026#34;???\u0026#34;}`); }); temp.c = 25; // \u0026#34;Celcius temp: 25\u0026#34; // \u0026#34;Fahrenheit temp: 77\u0026#34; temp.f = 212; // \u0026#34;Celcius temp: 100\u0026#34; // \u0026#34;Fahrenheit temp: 212\u0026#34; temp.f = null; // \u0026#34;Celcius temp: ???\u0026#34; // \u0026#34;Fahrenheit temp: ???\u0026#34; ","date":"30 December 2024","externalUrl":null,"permalink":"/posts/book_review_sicp/","section":"Posts","summary":"","title":"[Book Review]: Structure and Interpretation of Computer Programs","type":"posts"},{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/tags/typescript/","section":"Tags","summary":"","title":"Typescript","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]