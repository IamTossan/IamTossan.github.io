[{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/","section":"Blowfish","summary":"","title":"Blowfish","type":"page"},{"content":"I just finished reading that book, just before the end of the year. I wish I read these 600 pages earlier in my career.\nThe book consists of 5 parts. It starts with the basic elements of programming: arithmetic, variables, functions\u0026hellip; Then from these basic elements, we build towards more real-life problems to solve, using data structure, order of growth, function compositions and so on\u0026hellip; We define models that correspond to the problems we solve, or should I say, a language to express how we interact with the environment, so naturally we end with the 2 last parts having a taste of writing an interpreter and a compiler.\nHere\u0026rsquo;s some ideas from the book that I liked.\n1. Functional vs Object oriented vs Streams # In the book, we spend the first two parts using only functional programming. It is only in the third (after about 200 pages) that we are introduced to assignment which lead to encapsulation of local state. There is discussion about these two way and their respective challenges. Here\u0026rsquo;s an example:\nclass Account() { constructor(private balance: number) {} withdraw(amount: number): number { this.balance -= number; return this.balance; } } const acc = new Account(100); acc.withdraw(20); // 80 acc.withdraw(20); // 60 In object-oriented, we model things as entities that we can interact with and that can interact with each other. We model the changes of state with assignment. Successive calls to the same procedure can have different results, which can make a complex system difficult to reason with and to test, especially when multiple local states are correlated.\nconst withdrawSteam = (balance: number, amountStream: number[]): number =\u0026gt; { return amountStream.reduce((acc, cur) =\u0026gt; acc - cur, balance); }; console.log(withdrawSteam(100, [20, 20])); // 60 console.log(withdrawSteam(100, [20, 20])); // 60 In functional, we model things like an electrical circuit where each element outputs a computation based on its inputs. Successive calls will output the same results each time. In essence, we model time explicitly, however, time-related problems like when two changes to the same account occur (using mutexes), or and priority rules when merging streams need to be addressed.\n2. Dispatching on type and additivity # This is a powerful technique to obtain modularity in the implementation while keeping a clean API.\nconst getRealPart = (value) =\u0026gt; { if(type === \u0026#34;rectangular\u0026#34;) { ... } else if (type === \u0026#34;polar\u0026#34;) { ... } }; const getImagPart = (value) =\u0026gt; {...}; const getMagnitude = (value) =\u0026gt; {...}; const getAngle = (value) =\u0026gt; {...}; Here, if you need to add another type, you would need to go into every function.\nimport { rectangularOperations } from \u0026#34;somewhere-else\u0026#34;; const polarOperations = { getRealPart(value) {...}, getImagPart(value) {...}, getMagnitude(value) {...}, getAngle(value) {...}, }; const operationTable = { polar: polarOperations, rectangular: rectangularOperations, }; const applyOnComplexNumber = ( operation: string, complexNumber: { type: string; value: ComplexNumberValue }, ): [any, null] | [null, Error] =\u0026gt; { if (!operationTable[complexNumber.type]) { return [null, new Error(\u0026#34;type not implemented\u0026#34;)]; } if (!operationTable[complexNumber.type].operation) { return [ null, new Error( `operation {operation} not implemented on type {complexNumber.type}`, ), ]; } return [operationTable[complexNumber.type](complexNumber.value), null]; }; This way, we can easily package these operations by type and add another like a plugin.\n3. Constraints # This pattern can be used when the computation is not unidirectional and you need to propagate constraints, when a value depends on one or more others. This is a common thing in frontend frameworks nowadays, but I was pleasantly surprised to find this in a book originally written in 1985.\nclass Temperature { private _val: { c: null | number; f: null | number } = { c: null, f: null, }; private _cb: Array\u0026lt;(c: null | number, f: null | number) =\u0026gt; unknown\u0026gt; = []; set c(value: null | number) { if (value === null) { this._val = { c: null, f: null, }; } else { this._val = { c: value, f: (9 / 5) * value + 32, }; } this.onChange(); } set f(value: null | number) { if (value === null) { this._val = { c: null, f: null, }; } else { this._val = { f: value, c: (value - 32) * (5 / 9), }; } this.onChange(); } addCallback(f: (c: null | number, f: null | number) =\u0026gt; unknown) { this._cb.push(f); } onChange() { this._cb.forEach((cb) =\u0026gt; cb(this._val.c, this._val.f)); } } const temp = new Temperature(); temp.addCallback((c, f) =\u0026gt; { console.log(`Celcius temp: ${c ?? \u0026#34;???\u0026#34;}`); console.log(`Fahrenheit temp: ${f ?? \u0026#34;???\u0026#34;}`); }); temp.c = 25; // \u0026#34;Celcius temp: 25\u0026#34; // \u0026#34;Fahrenheit temp: 77\u0026#34; temp.f = 212; // \u0026#34;Celcius temp: 100\u0026#34; // \u0026#34;Fahrenheit temp: 212\u0026#34; temp.f = null; // \u0026#34;Celcius temp: ???\u0026#34; // \u0026#34;Fahrenheit temp: ???\u0026#34; ","date":"30 December 2024","externalUrl":null,"permalink":"/posts/book_review_sicp/","section":"Posts","summary":"","title":"Book Review: Structure and Interpretation of Computer Programs","type":"posts"},{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/tags/typescript/","section":"Tags","summary":"","title":"Typescript","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]